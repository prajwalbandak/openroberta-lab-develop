# This file is automatically generated by the Open Roberta Lab.
const _M_MAX = 5
const _RGB_DIV = 8
const _LED_DIV = 3

var _A               # helper variable to store results of type number
var _B[1]            # helper variable to store results from the left side of a binary expression
var _C[1]            # helper variable to store results from the right side of a binary expression
var _state = 2       # current state of the program flow
var _time            # current elapsed time
var _method_count = -1
var _return_state[2]
var ___duration_
var ___led_[8]
var ___color_[3]
timer.period[0] = 10 # ms time between state executions

onevent timer0
    if _state == 0 then
        _time = 0
        _A = 30
        motor.left.target = _M_MAX * -_A
        motor.right.target = _M_MAX * -_A
        _A = 1000
        ___duration_ = _A / timer.period[0]
        _state = 3
    elseif _state == 3 then
        if _time == ___duration_ then
            callsub diffdrive_stop
            _state = 4
        else
            _time++
        end
    elseif _state == 4 then
        _method_count++
        _return_state[_method_count] = 5
        callsub ____driveMore
    elseif _state == 5 then
        _method_count--
        _state = _return_state[_method_count]
    elseif _state == 1 then
        _A = 30
        motor.left.target = _M_MAX * _A
        motor.right.target = _M_MAX * _A
        callsub diffdrive_stop
        _time = 0
        _A = 30
        motor.left.target = _M_MAX * _A
        motor.right.target = _M_MAX * -_A
        _A = 1000
        ___duration_ = _A / timer.period[0]
        _state = 6
    elseif _state == 6 then
        if _time == ___duration_ then
            callsub diffdrive_stop
            _state = 7
        else
            _time++
        end
    elseif _state == 7 then
        _A = 30
        motor.left.target = _M_MAX * _A
        motor.right.target = _M_MAX * -_A
        _time = 0
        _A = 10
        motor.left.target = _M_MAX * _A
        _A = 30
        motor.right.target = _M_MAX * _A
        _A = 1000
        ___duration_ = _A / timer.period[0]
        _state = 8
    elseif _state == 8 then
        if _time == ___duration_ then
            callsub diffdrive_stop
            _state = 9
        else
            _time++
        end
    elseif _state == 9 then
        _A = 10
        motor.left.target = _M_MAX * _A
        _A = 30
        motor.right.target = _M_MAX * _A
        _state = _return_state[_method_count]
    elseif _state == 2 then
        _time = 0
        _A = 30
        motor.left.target = _M_MAX * _A
        _A = 1000
        ___duration_ = _A / timer.period[0]
        _state = 10
    elseif _state == 10 then
        if _time == ___duration_ then
            motor.left.target = 0
            _state = 11
        else
            _time++
        end
    elseif _state == 11 then
        _A = 30
        motor.left.target = _M_MAX * _A
        motor.left.target = 0
        _time = 0
        _A = 30
        motor.left.target = _M_MAX * _A
        motor.right.target = _M_MAX * _A
        _A = 1000
        ___duration_ = _A / timer.period[0]
        _state = 12
    elseif _state == 12 then
        if _time == ___duration_ then
            callsub diffdrive_stop
            _state = 13
        else
            _time++
        end
    elseif _state == 13 then
        _method_count++
        _return_state[_method_count] = 14
        callsub ____driveBack
    elseif _state == 14 then
        _method_count--
        _time = 0
        ___duration_ = 2000 / timer.period[0]
        call sound.freq(261, 2000/16)
        _state = 15
    elseif _state == 15 then
        if _time == ___duration_ then
            _state = 16
        else
            _time++
        end
    elseif _state == 16 then
        _time = 0
        _A = 100
        ___duration_ = _A
        _A = 300
        call sound.freq(_A, ___duration_ / 16)
        ___duration_ /= timer.period[0]
        _state = 17
    elseif _state == 17 then
        if _time == ___duration_ then
            _state = 18
        else
            _time++
        end
    elseif _state == 18 then
        _time = 0
        call sound.system(0)
        ___duration_ = 1000 / timer.period[0]
        _state = 19
    elseif _state == 19 then
        if _time == ___duration_ then
            _state = 20
        else
            _time++
        end
    elseif _state == 20 then
        _time = 0
        _A = 1
        call sound.duration(_A, ___duration_)
        ___duration_=___duration_ * 10
        call sound.replay(_A)
        _state = 21
    elseif _state == 21 then
        if _time == ___duration_ then
            _state = 22
        else
            _time++
        end
    elseif _state == 22 then
        _A = 100
        ___led_[0] = _A / _LED_DIV
        _A = 100
        ___led_[1] = _A / _LED_DIV
        _A = 100
        ___led_[2] = _A / _LED_DIV
        _A = 100
        ___led_[3] = _A / _LED_DIV
        call leds.buttons(___led_[0], ___led_[1], ___led_[2], ___led_[3])
        _A = 100
        ___led_[0] = _A / _LED_DIV
        _A = 100
        ___led_[1] = _A / _LED_DIV
        _A = 100
        ___led_[2] = _A / _LED_DIV
        _A = 100
        ___led_[3] = _A / _LED_DIV
        _A = 100
        ___led_[4] = _A / _LED_DIV
        _A = 100
        ___led_[5] = _A / _LED_DIV
        _A = 100
        ___led_[6] = _A / _LED_DIV
        _A = 100
        ___led_[7] = _A / _LED_DIV
        call leds.circle(___led_[0], ___led_[1], ___led_[2], ___led_[3], ___led_[4], ___led_[5], ___led_[6], ___led_[7])
        _A = 0
        ___led_[0] = _A / _LED_DIV
        _A = 0
        ___led_[1] = _A / _LED_DIV
        call leds.prox.v(___led_[0], ___led_[1])
        _A = 100
        ___led_[0] = _A / _LED_DIV
        _A = 100
        ___led_[1] = _A / _LED_DIV
        _A = 100
        ___led_[2] = _A / _LED_DIV
        _A = 100
        ___led_[3] = _A / _LED_DIV
        _A = 100
        ___led_[4] = _A / _LED_DIV
        _A = 100
        ___led_[5] = _A / _LED_DIV
        _A = 100
        ___led_[6] = _A / _LED_DIV
        _A = 100
        ___led_[7] = _A / _LED_DIV
        call leds.prox.h(___led_[0], ___led_[1], ___led_[2], ___led_[3], ___led_[4], ___led_[5], ___led_[6], ___led_[7])
        _A = 100
        ___led_[0] = _A / _LED_DIV
        call leds.sound(___led_[0])
        _A = 100
        ___led_[0] = _A / _LED_DIV
        _A = 100
        ___led_[1] = _A / _LED_DIV
        call leds.temperature(___led_[0], ___led_[1])
        _time = 0
        _A = 5000
        ___duration_ = _A / timer.period[0]
        _state = 23
    elseif _state == 23 then
        if _time == ___duration_ then
            _state = 24
        else
            _time++
        end
    elseif _state == 24 then
        _state = 25
    elseif _state == 25 then
        _A = 1
        _B[0] = _A
        _A = 1
        _C[0] = _A
        if _B[0] == 1 and _C[0] == 1 then
            _A = 1
        else
            _A = 0
        end
        if _A == 1 then
            _state = 26
        end
    elseif _state == 26 then
        _state = 27
    elseif _state == 27 then
        ___color_ = [204, 0, 0]
        call leds.top(___color_[0] / _RGB_DIV, ___color_[1] / _RGB_DIV, ___color_[2] / _RGB_DIV)
        _A = 255
        ___color_[0] = _A
        _A = 20
        ___color_[1] = _A
        _A = 150
        ___color_[2] = _A
        call leds.top(___color_[0] / _RGB_DIV, ___color_[1] / _RGB_DIV, ___color_[2] / _RGB_DIV)
        call leds.top(0, 0, 0)
        callsub thymio_close
    end

sub ____driveBack
    _state = 0

sub ____driveMore
    _state = 1

sub diffdrive_stop
    motor.left.target = 0
    motor.right.target = 0

sub thymio_close
    timer.period[0] = 0
    motor.left.target = 0
    motor.right.target = 0
    call leds.buttons(0, 0, 0, 0)
    call leds.circle(0, 0, 0, 0, 0, 0, 0, 0)
    call leds.prox.v(0, 0)
    call leds.prox.h(0, 0, 0, 0, 0, 0, 0, 0)
    call leds.sound(0)
    call leds.temperature(0, 0)
    call leds.top(0, 0, 0)
    