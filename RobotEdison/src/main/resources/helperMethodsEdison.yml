include: "classpath:/common.methods.yml"
# method names are based on FunctionNames and EdisonUsedHardwareCollectorVisitor.Method
# languages are based on HelperMethodGenerator.Language

## FunctionNames

PRIME:
  PYTHON: |
    def _isPrime(num):
        if num <= 1: 
            return False
        newNum = num - 2
        for x in range(newNum):
            y = (x + 2)
            if (num % y) == 0: 
                return False
        return True

# not prefixed with _ because many super methods generate the standard python sum/min/max which would have to be overridden
MIN:
  PYTHON: |
    def min(list):
        listMin = list[0]
        listLength = len(list)
        for i in range(listLength):
            if list[i] < listMin:
                listMin = list[i]
        return listMin
MAX:
  PYTHON: |
    def max(list):
        listMax = list[0]
        listLength = len(list)
        for i in range(listLength):
            if list[i] > listMax:
                listMax = list[i]
        return listMax
SUM:
  PYTHON: |
    def sum(list):
        listSum = 0
        listLength = len(list)
        for i in range(listLength): 
            listSum = (listSum + list[i])
        return listSum

ABS:
  PYTHON: |
    def _abs(num):
        if (num < 0): 
            return -num
        else: 
            return num
# this is also used by POW10
POWER:
  PYTHON: |
    def _pow(base, exp):
        result = 1
        b = base
        for _ in range(exp):
            result *= b
        return result

## EdisonUsedHardwareCollectorVisitor.Method

OBSTACLEDETECTION:
  PYTHON: |
    def _obstacleDetection(mode):
        global obstacleDetectionOn
        if (obstacleDetectionOn == False):
            Ed.ObstacleDetectionBeam(Ed.ON)
            obstacleDetectionOn = True
        return Ed.ReadObstacleDetection() == mode

IRSEND:
  PYTHON: |
    def _irSend(payload):
        global obstacleDetectionOn
        if (obstacleDetectionOn == True):
            Ed.ObstacleDetectionBeam(Ed.OFF)
            obstacleDetectionOn = False
        Ed.SendIRData(payload)

# mode: 0 = edison IR data; 1 = remote control data
IRSEEK:
  PYTHON: |
    def _irSeek(mode):
        global obstacleDetectionOn
        if (obstacleDetectionOn == True):
            Ed.ObstacleDetectionBeam(Ed.OFF)
            obstacleDetectionOn = False
        if (mode == 0): 
            return Ed.ReadIRData()
        elif (mode == 1): 
            return Ed.ReadRemote()

# motor: 0 = LMOTOR; 1 = RMOTOR
# distance: Entweder integer oder Ed.DISTANCE_UNLIMITED
MOTORON:
  PYTHON: |
    def _motorOn(motor, power, distance):
        _dir = Ed.FORWARD
        _reverse = False
        if (power < 0):
            _power = _shorten(-power)
            _reverse = True
        else: _power = _shorten(power)
        if (motor == Ed.MOTOR_LEFT):
            if (_power == 0): 
                Ed.DriveLeftMotor(Ed.STOP, 0, 0)
            else: 
                Ed.DriveLeftMotor(_getDirection(_dir, _reverse), _power, distance)
        if (motor == Ed.MOTOR_RIGHT):
            if (_power == 0): 
                Ed.DriveRightMotor(Ed.STOP, 0, 0)
            else: 
                Ed.DriveRightMotor(_getDirection(_dir, _reverse), _power, distance)

DIFFCURVE:
  PYTHON: |
    def _diffCurve(direction, leftSpeed, rightSpeed, distance):
        if (leftSpeed < 0): 
            _leftSpeed = _shorten(-leftSpeed)
            _reverseLeft = True
        else: 
            _leftSpeed = _shorten(leftSpeed)
            _reverseLeft = False
        if (rightSpeed < 0): 
            _rightSpeed = _shorten(-rightSpeed)
            _reverseRight = True
        else: 
            _rightSpeed = _shorten(rightSpeed)
            _reverseRight = False
        if (_leftSpeed > _rightSpeed):
            if (_rightSpeed == 0):
                Ed.DriveRightMotor(Ed.STOP, 0, 0)
            else:
                Ed.DriveLeftMotor(_getDirection(direction, _reverseLeft), _leftSpeed, Ed.DISTANCE_UNLIMITED)
                Ed.DriveRightMotor(_getDirection(direction, _reverseRight), _rightSpeed, Ed.DISTANCE_UNLIMITED)
            Ed.DriveLeftMotor(_getDirection(direction, _reverseLeft), _leftSpeed, distance)
            if (distance != Ed.DISTANCE_UNLIMITED): 
                Ed.Drive(Ed.STOP, 1, 1)
        elif (_leftSpeed < _rightSpeed):
            if (_leftSpeed == 0):
                Ed.DriveLeftMotor(Ed.STOP, 0, 0)
            else:
                Ed.DriveRightMotor(_getDirection(direction, _reverseRight), _rightSpeed, Ed.DISTANCE_UNLIMITED)
                Ed.DriveLeftMotor(_getDirection(direction, _reverseLeft), _leftSpeed, Ed.DISTANCE_UNLIMITED)
            Ed.DriveRightMotor(_getDirection(direction, _reverseRight), _rightSpeed, distance)
            if (distance != Ed.DISTANCE_UNLIMITED): 
                Ed.Drive(Ed.STOP, 1, 1)
        else:
            if (_leftSpeed == 0):
                Ed.Drive(Ed.STOP, 1, 1)
            else:
                Ed.Drive(_getDirection(direction, _reverseLeft), _leftSpeed, distance)

DIFFDRIVE:
  PYTHON: |
    def _diffDrive(direction, speed, distance):
        _reverse = False
        if speed < 0:
            _reverse = True
            _speed = _shorten(-speed)
        else: 
            _speed = _shorten(speed)
        if (_speed == 0): 
            Ed.Drive(Ed.STOP, 1, 1)
        else: 
            Ed.Drive(_getDirection(direction, _reverse), _speed, distance)

DIFFTURN:
  PYTHON: |
    def _diffTurn(direction, speed, degree):
        _reverse = False
        if speed < 0:
            _reverse = True
            _speed = _shorten(-speed)
        else: 
            _speed = _shorten(speed)
        if (_speed == 0): 
            Ed.Drive(Ed.STOP, 1, 1)
        elif _reverse:
            if direction == Ed.SPIN_RIGHT: 
                Ed.Drive(Ed.SPIN_LEFT, _speed, degree)
            else: 
                Ed.Drive(Ed.SPIN_RIGHT, _speed, degree)
        else: 
            Ed.Drive(direction, _speed, degree)

SHORTEN:
  PYTHON: |
    def _shorten(num): 
        return ((num+5)/10)

GETDIR:
  PYTHON: |
    def _getDirection(dir, reverse):
        if reverse:
            if (dir == Ed.FORWARD): 
                return Ed.BACKWARD
            else: 
                return Ed.FORWARD
        else: 
            return dir
